[
  {
    "objectID": "C03_covariates.html",
    "href": "C03_covariates.html",
    "title": "Covariates",
    "section": "",
    "text": "“In the end that was the choice you made, and it doesn’t matter how hard it was to make it. It matters that you did.”\n\nCassandra Clare\nNow we turn our attention to what we know and guess about the environments. We are using the Brickman data to make habitat suitability maps for select species under two climate scenarios (RCP45 and RCP85) at two different times (2055 and 2075) in the future. Each variable we might use is called covariate or predictor. Our covariates are nicely packaged up and tidy, but the reality is that it often requires a good deal of data wrangling if the data are messy.\nOur step here is to make sure that two or more covariates are not highly correlated if they are, then we would likely want to drop all but one.",
    "crumbs": [
      "Covariates"
    ]
  },
  {
    "objectID": "C03_covariates.html#reading-in-the-covariates",
    "href": "C03_covariates.html#reading-in-the-covariates",
    "title": "Covariates",
    "section": "2.1 Reading in the covariates",
    "text": "2.1 Reading in the covariates\nWe’ll read in the Brickman database, then filter two different subsets to read: “STATIC” covariate bathymetry that apply across all scenarios and times and monthly covariates for the “PRESENT” period. Note that depth is automatically included - that’s an option - see ?read_brickman for more information.\n\ndb = brickman_database()\npresent = read_brickman(filter(db, scenario == \"PRESENT\", interval == \"mon\"))\n\nWe have used August before as our example, let’s continue with August.\n\naug = present |&gt;\n  dplyr::slice(\"month\", \"Aug\")",
    "crumbs": [
      "Covariates"
    ]
  },
  {
    "objectID": "C03_covariates.html#make-a-pairs-plot",
    "href": "C03_covariates.html#make-a-pairs-plot",
    "title": "Covariates",
    "section": "2.2 Make a pairs plot",
    "text": "2.2 Make a pairs plot\nA pairs plot is a plot often used in exploratory data analysis. It makes a grid of mini-plots of a set of variables, and reveals the relationships among the variables pair-by-pair. It’s easy to make.\n\npairs(aug)\n\n\n\n\n\n\n\n\nIn the lower left portion of the plot we see paired scatter plots, at upper right we see the correlation values of the pairs, and long the diagonal we see a histogram of each variable. Some pairs are highly correlated, say over 0.7, and to include both in the modeling might not provide us with greater predictive power. It may feel counterintuitive to remove any variables - more data means more information, right? And more information means more informed models. Consider two measurements, human arm length and inseam. We might use these to predict if a person is tall, but since they are probably strongly collinear/correlated do we really need both?",
    "crumbs": [
      "Covariates"
    ]
  },
  {
    "objectID": "C03_covariates.html#identify-the-most-independent-variables-and-the-most-collinear",
    "href": "C03_covariates.html#identify-the-most-independent-variables-and-the-most-collinear",
    "title": "Covariates",
    "section": "2.3 Identify the most independent variables (and the most collinear)",
    "text": "2.3 Identify the most independent variables (and the most collinear)\nWe have a function that can help use select which variables to remove. filter_collinear() returns a listing of variables it suggests we keep. It attaches to the return value an attribute (like a post-it note stuck on a box) that lists the complementary variables that it suggests we drop. We are choosing a particular method, but you can learn more about using R’s help for ?filter_collinear.\n\nkeep = filter_collinear(aug, method = \"vif_step\")\nkeep\n\n[1] \"MLD\"  \"Sbtm\" \"SSS\"  \"SST\"  \"Tbtm\" \"U\"    \"V\"   \nattr(,\"to_remove\")\n[1] \"Xbtm\"  \"depth\"\n\n\nOf course, we can decide to ignore this advice, and pick which ever ones we want including keeping them all.\nWhatever selection of variables we decide to model with, we will save this listing to a file. That way we can refer to it programmatically, but that comes later.",
    "crumbs": [
      "Covariates"
    ]
  },
  {
    "objectID": "C03_covariates.html#a-closer-look-at-the-model-input-data",
    "href": "C03_covariates.html#a-closer-look-at-the-model-input-data",
    "title": "Covariates",
    "section": "2.4 A closer look at the model input data",
    "text": "2.4 A closer look at the model input data\nBefore we do commit to a selection of variables, let’s turn our attention back to our presence-background points, and look at just those chosen values rather than at values drawn form across the entire domain. Let’s open the file that contains the “greedy” model input for August during the PRESENT climate scenario.\n\nmodel_input = read_model_input(scientificname = \"Mola mola\", \n                               mon = \"Aug\")\nmodel_input\n\nSimple feature collection with 1364 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -74.72716 ymin: 38.868 xmax: -65.02004 ymax: 45.54306\nGeodetic CRS:  WGS 84\n# A tibble: 1,364 × 3\n   month class                    geom\n   &lt;chr&gt; &lt;chr&gt;             &lt;POINT [°]&gt;\n 1 Aug   presence     (-69.569 42.022)\n 2 Aug   presence     (-65.383 42.483)\n 3 Aug   presence        (-67.37 42.4)\n 4 Aug   presence       (-65.55 41.58)\n 5 Aug   presence     (-72.118 40.651)\n 6 Aug   presence       (-67.02 43.91)\n 7 Aug   presence     (-68.983 40.267)\n 8 Aug   presence (-69.61571 42.90769)\n 9 Aug   presence        (-68.56 42.2)\n10 Aug   presence     (-68.175 42.088)\n# ℹ 1,354 more rows\n\n\nNext we’ll extract data values from our August covariates.\n\nvariables = extract_brickman(aug, model_input, form = \"wide\")\nvariables\n\n# A tibble: 1,364 × 10\n   point   MLD  Sbtm   SSS   SST  Tbtm         U         V     Xbtm  depth\n   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n 1 p0001  4.76  34.5  30.7  19.8  7.40  0.000146 -0.000420 0.000158  204. \n 2 p0002  3.95  33.5  30.7  18.6  6.11 -0.0127   -0.0153   0.00717    99.7\n 3 p0003  5.09  34.8  30.7  19.1  7.33  0.00155   0.000119 0.000552  318. \n 4 p0004  5.18  35.0  31.7  20.3  3.65  0.0238   -0.0747   0.0353   2118. \n 5 p0005  3.93  31.8  30.5  21.4  8.28 -0.00206   0.00562  0.00213    46.3\n 6 p0006  5.36  33.9  30.6  18.8  6.94  0.00342  -0.00144  0.00131   130. \n 7 p0007  3.99  34.5  31.1  21.2  9.20 -0.000837 -0.00310  0.00114   113. \n 8 p0008  4.99  34.3  30.6  18.7  7.31  0.00643  -0.00311  0.00254   177. \n 9 p0009  4.85  34.5  30.7  19.5  7.39  0.00256   0.00160  0.00107   180. \n10 p0010  4.87  34.7  30.7  19.6  7.41 -0.0115   -0.00125  0.00411   206. \n# ℹ 1,354 more rows\n\n\nWe are going to call a plotting function, plot_pres_vs_bg(), that wants some of the data from model_input and some of the data in variables. So, we have to do some data wrangling to combine those; we’ll add class to variables and then drop the point column.\n\nvariables = variables |&gt;\n  mutate(class = model_input$class) |&gt;    # the $ extracts a column \n  select(-point)                          # the - means \"deselect\" or \"drop\"\nvariables\n\n# A tibble: 1,364 × 10\n     MLD  Sbtm   SSS   SST  Tbtm         U         V     Xbtm  depth class   \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;   \n 1  4.76  34.5  30.7  19.8  7.40  0.000146 -0.000420 0.000158  204.  presence\n 2  3.95  33.5  30.7  18.6  6.11 -0.0127   -0.0153   0.00717    99.7 presence\n 3  5.09  34.8  30.7  19.1  7.33  0.00155   0.000119 0.000552  318.  presence\n 4  5.18  35.0  31.7  20.3  3.65  0.0238   -0.0747   0.0353   2118.  presence\n 5  3.93  31.8  30.5  21.4  8.28 -0.00206   0.00562  0.00213    46.3 presence\n 6  5.36  33.9  30.6  18.8  6.94  0.00342  -0.00144  0.00131   130.  presence\n 7  3.99  34.5  31.1  21.2  9.20 -0.000837 -0.00310  0.00114   113.  presence\n 8  4.99  34.3  30.6  18.7  7.31  0.00643  -0.00311  0.00254   177.  presence\n 9  4.85  34.5  30.7  19.5  7.39  0.00256   0.00160  0.00107   180.  presence\n10  4.87  34.7  30.7  19.6  7.41 -0.0115   -0.00125  0.00411   206.  presence\n# ℹ 1,354 more rows\n\n\nFinally, can make a specialized plot comparing our variables for each class: presence and background.\n\nplot_pres_vs_bg(variables, \"class\")\n\n\n\n\n\n\n\n\nHow does this inform our thinking about reducing the number of variables? For which variables do presence and background values mirror each other? Which have the least overlap? We know that the model works by finding optimal combinations of covariates for the species. If there is never a difference between the conditions for presences and background then how will it find the optimal niche conditions?",
    "crumbs": [
      "Covariates"
    ]
  },
  {
    "objectID": "C03_covariates.html#saving-a-file-to-keep-track-of-modeling-choices",
    "href": "C03_covariates.html#saving-a-file-to-keep-track-of-modeling-choices",
    "title": "Covariates",
    "section": "2.5 Saving a file to keep track of modeling choices",
    "text": "2.5 Saving a file to keep track of modeling choices\nYou may have noticed that we write a lot of things to files (aka, “writing to disk”). It’s a useful practice especially when working with a multi-step process. One particular file, a configuration file, is used frequently in data science to store information about the choices we make as we work through our project. Configuration files generally are simple text files that we can easily get the computer to read and write.\nIn R, a confguration is treated as a named list. Each element of a list is named, but beyond that there aren’t any particular rules about confugurations. You can learn more about configurations in this tutorial.\nLet’s make a configuration list that holds 4 items: version identifier, species name and the names of the variables to model with.\n\ncfg = list(\n  version = \"Aug\",\n  scientificname = \"Mola mola\",\n  mon = \"Aug\",\n  keep_vars =  keep)\n\nWe can access by name three ways using what is called “indexing” : using the [[ indexing brackets, using the $ indexing operator or using the getElement() function.\n\ncfg[['scientificname']]\n\n[1] \"Mola mola\"\n\ncfg[[2]]\n\n[1] \"Mola mola\"\n\ncfg$scientificname\n\n[1] \"Mola mola\"\n\ngetElement(cfg, \"scientificname\")\n\n[1] \"Mola mola\"\n\ngetElement(cfg, 2)\n\n[1] \"Mola mola\"\n\n\nNow we’ll write this list to a file. First let’s set up a path where we might store these configurations, and for that matter, to store our modeling files. We’ll make a new directory, models/Aug and write the configuration there. We’ll use the famous “YAML” format to store the file. See the file functions/configuration.R for documentation on reading and writing.\n\nok = make_path(data_path(\"models\")) # make a directory for models\nwrite_configuration(cfg)            \n\nUse the Files pane to navigate to your personal data directory. Open the Aug.yaml file - this is what you configuration looks like in YAML. Fortunately we don’t mess by hand with these much.\nversion: Aug\nscientificname: Mola mola\nmon: Aug\nkeep_vars:\n- MLD\n- Sbtm\n- SSS\n- SST\n- Tbtm\n- U\n- V",
    "crumbs": [
      "Covariates"
    ]
  },
  {
    "objectID": "C03_covariates.html#challenge-c03",
    "href": "C03_covariates.html#challenge-c03",
    "title": "Covariates",
    "section": "4.1 Challenge C03",
    "text": "4.1 Challenge C03\nWrite a function that will read all of your configurations, and then generate a listing of the variables common to every model and a second listing of the ones that are not. Hint: see the help for intersect() and setdiff.",
    "crumbs": [
      "Covariates"
    ]
  }
]